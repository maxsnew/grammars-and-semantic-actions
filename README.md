# Intrinsic Verification of Parsers and Formal Grammar Theory in Dependent Lambek Calculus

## Getting Started

TODO instructions for getting/loading container

### Compiling the repository

From the `code/Cubical` directory, `make` will compile `README.agda` which imports the entirety of the project. 

`README.agda` imports several files of the form `${dir}.Everything`. In a directory `dir`, the module `${dir}.Everything` imports all the modules within `dir` or any of its submodules. These `Everything` files are automatically generated by the target `make gen-and-check-everythings`. 

Compiling `README.agda` will then build the whole project, but this may take longer than 30 minutes, as it also must compile dependencies from `cubical` and `cubical-categorical-logic`. If the compilation doesn't immediately crash, it is very likely that the container is working properly. If the reviewer desires a quicker, complete litmus test for technical issues, we have also included the target `make litmus` which builds only the `Grammar` submodule. 

## High-Level Layout
This artifact is split into the following directories 
- `String` - contains the defintion as the list type over some fixed alphabet, and some associated utilities. `String := List ⟨ Alphabet ⟩`, where `Alphabet : hSet`
- `Grammar` - defining the primitive linear types in Dependent Lambek Calculus. Linear types are encoded as functions from strings to types, written as `Grammar ℓA = String → Type ℓA`.
- `Term` - defining parse transformers between grammars. A parse transformer between `A` and `B` is written as the type `A ⊢ B` (or `Term A B`).
- `Parser` - the definition of a parser as described in definiton 4.4.
- `Automata` - defining the following automata formalisms as grammars: DFAs, NFAs, deterministic (but not necessarily finite) automata, and Turing machines.
- `Examples` - containing intrinsically verified parsers for the Dyck grammar and an arithmetic expression grammar. Additionally has the examples from the figures in Section 2 encoded.
- `Thompson` - a verification of Thompson's construction: from a regular expression `r` construct an NFA and prove that it is strongly equivalent to `r`.
- `Determinization` - a verification of the powerset construction for determinization. Given an NFA `N`, construct a DFA that is weakly equivalent to it.
- `Cubical` - utilities that supplement the `Cubical` standard library.
- `Lexer` - An experimental module that defines a lexer as a translation between alphabets. Used for experimenting with language ergonomics, but not a dependence to any claims presented.

### Experimental

The following modules are experimental. They are not used in our examples or dependencies to any claims presented in the paper.

- `Lexer`
- `Grammar.LinearProduct.SplittingTrichotomy`
- `Grammar.SequentialUnambiguity`
- `Grammar.PropositionalTruncation`
- `Grammar.Coinductive`
- `Grammar.Subgrammar`
- `Automata.PDA`
- `String.ASCII`
- `String.Unicode`
- `String.SubAlphabet`

## Claims

- TODO the axioms we assert hold in the semantics
- TODO `βη` laws

- Lemma 4.3: If `B` is unambiguous and `A` is a retract of `B`, then `A` is unambiguous.
- Lemma 4.3: If a disjunction `⊕[ x ∈ X ] A x` is unambiguous then each `A x` is unambiguous
- Definition 4.4
- Lemma 4.5: If `A ⊕ B` is unambiguous, then `A` and `B` are disjoint.
- Lemma 4.6: If `A` is weakly equivalent to `B`, then any parser for `A` can be extended to a parser for `B`.
- Theorem 4.7: A parser for the accepting traces of a DFA.
- Theorem 4.8 (Determinization): For an NFA `N`, there exists a DFA `D` such that `Parse D` is weakly equivalent to `Parse N`.
- Theorem 4.9 (Thompson's Construction): For a regular expression `r`, there exists and NFA `N` such that `r` is strongly equivalent to `Parse N`.
- Theorem 4.10: `Dyck` is strongly equivalent to `Parse M`, and therefore we can build a `Dyck` parser.
- Theorem 4.11: We construct a parser for `Exp` by showing that it is weakly equivalent to the accepting traces from the opening state with its stack set to `0`.
- Theorem 4.12: for any Turing machine `T`, we construct a grammar that accepts the same language as `T`.

## Caveats

TODO pragmas, opacity, IO
TODO combinatory style, levels
