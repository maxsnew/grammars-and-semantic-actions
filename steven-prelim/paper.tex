% -*- fill-column: 80; -*-
\documentclass[sigconf,screen,nonacm]{acmart}
\usepackage{mathpartir}
\usepackage{tikz-cd}
\usepackage{lipsum}
\usepackage{enumitem}
\usepackage{wrapfig}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{stmaryrd}

\usepackage{todonotes}
\newcommand{\todoin}[1]{\todo[inline]{TODO:\@ #1}}

\newcommand{\sem}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand{\lto}{\multimap}
\newcommand{\tol}{\mathrel{\rotatebox[origin=c]{180}{$\lto$}}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Gr}{\mathbf{Gr}}
\newcommand{\Type}{\mathbf{Type}}
\newcommand{\Prop}{\mathbf{Prop}}
\newcommand{\Bool}{\mathbf{Bool}}
\newcommand{\nat}{\mathbb{N}}

\newcommand{\gluedNL}{{\mathcal G}_S}
\newcommand{\gluedNLUniv}{{\mathcal G}_{S,i}}
\newcommand{\gluedL}{{\mathcal G}_L}

\newcommand{\simulsubst}[2]{#1\{#2\}}
\newcommand{\subst}[3]{\simulsubst {#1} {#2/#3}}
\newcommand{\letin}[3]{\mathsf{let}\, #1 = #2 \, \mathsf{in}\, #3}
\newcommand{\lamb}[2]{\lambda #1.\, #2}
\newcommand{\lamblto}[2]{\lambda^{{\lto}} #1.\, #2}
\newcommand{\lambtol}[2]{\lambda^{{\tol}} #1.\, #2}
\newcommand{\dlamb}[2]{\overline{\lambda} #1.\, #2}
\newcommand{\app}[2]{#1 \, #2}
\newcommand{\applto}[2]{#1 \mathop{{}^{\lto}} #2}
\newcommand{\apptol}[2]{#1 \mathop{{}^{\tol}} #2}
\newcommand{\PiTy}[3]{\Pi #1 : #2.\, #3}
\newcommand{\SigTy}[3]{\Sigma #1 : #2.\, #3}
\newcommand{\LinPiTy}[3]{\widebar\Pi #1 : #2.\, #3}
\newcommand{\LinSigTy}[3]{\widebar\Sigma #1 : #2.\, #3}
\newcommand{\amp}{\mathrel{\&}}
\newcommand{\GrTy}{\mathsf{Gr}}

\newcommand{\ctxwff}[1]{#1 \,\, \mathsf{ok}}
\newcommand{\ctxwffjdg}[2]{#1 \vdash #2 \,\, \mathsf{type}}
\newcommand{\linctxwff}[2]{#1 \vdash #2 \,\, \mathsf{ok}}
\newcommand{\linctxwffjdg}[2]{#1 \vdash #2 \,\, \mathsf{linear}}

\newif\ifdraft
\drafttrue
\newcommand{\steven}[1]{\ifdraft{\color{orange}[{\bf Steven}: #1]}\fi}
\renewcommand{\max}[1]{\ifdraft{\color{blue}[{\bf Max}: #1]}\fi}
\newcommand{\pedro}[1]{\ifdraft{\color{red}[{\bf Pedro}: #1]}\fi}
\newcommand{\pipe}{\,|\,}

\begin{document}

\title{CSE Preliminary Examination}
\author{Steven Schaefer}
\affiliation{\department{Electrical Engineering and Computer Science}
  \institution{University of Michigan}
  \country{USA}
}
\email{stschaef@umich.edu}

\maketitle
\pagestyle{plain}

\section*{Distribution of Work}
\todoin{I need to describe what my contributions are, but it needs to sounds
  more natrual than below}
This work was conducted with Max New, one of my advisors, and Pedro H.A. de
Amorim, a collaborator at Oxford. The majority of this paper is adapted from a
draft written by Max, Pedro, and I for submission to LICS in January. We did not submit
to LICS, and now we are targetting submission to POPL in July.

This paper is an adaptation of my contributions to the LICS draft. In summary,
these include the proofs presented, contribution to the formation of
inference rules, choice of axioms, and an ongoing formalization effort in Agda of
several of the included constructions.

From the LICS draft I am omitting some work from Max and Pedro that may be
relevant to this paper, although not directly necessary. Some of these omissions
include a canonicity result for the type theory and a categorification of Kleene
algebras.

\todoin{I want to describe some cubical contributions as well, even if not
  entirely relevant to this paper. Something
  something resuable library code? After all, some of it is used in the formalization}

\listoftodos{list of todos}

\pagebreak

\title{Formal Grammars as Types in Non-commutative Linear-Non-Linear Type Theory}

\author{Max S. New}
\affiliation{
  \department{Electrical Engineering and Computer Science}
  \institution{University of Michigan}
  \country{USA}
}
\email{maxsnew@umich.edu}

\author{Pedro H. Azevedo de Amorim}
\affiliation{
  \department{Department of Computer Science}
  \institution{University of Oxford}
  \country{UK}
}
\email{pedro.azevedo.de.amorim@cs.ox.ac.uk}


\begin{abstract}
  In this paper, we
  provide a syntax-independent notion of formal grammar. Semantically, we view a grammar as a function from
  strings to sets of parse trees, generalizing from the familiar notion of a language
  as a set of strings. This point-of-view naturally endows a grammar with the
  structure of a presheaf, which allows many language-theoretic constructs to be
  defined via universal properties.

  With these categorical constructions in mind, we propose a new syntactic
  formalism for formal grammars: a version of dependent linear-non-linear type
  theory where the tensor product is non-commutative. The linear types in this
  theory are interpreted as grammars --- and linear terms as parse transformers.

  Classically, many results in both language and automata theory are proved
  informally with respect to some ambient foundation --- e.g. Kleene algebra, grammars,
  parsers, semantic actions, etc. The type theory provided in
  this paper serves as an intuitive and general framework to syntactically unify
  these related ideas and internalize their
  theorems formally. We give a new \emph{logical characterization} of
  grammar classes based on a substructural logic rather than ordinary
  first-order logic.

  The non-dependent fragment of this type theory is already expressive enough to
  capture regular expressions, context-free expressions, and finite automata.
  Moreover, several classic theorems --- such as the equivalence between regular languages and finite automata --- are
  definable as proof terms in this formalism.
  Further, through use of dependency of linear types on non-linear types, we can express richer grammar
  formalisms such as indexed grammars, pushdown automata, and Turing machines.

  We give this type theory a semantics in the category of grammars and
  prove a related canonicity theorem. Moreover, we keep an eye toward the
  implementation of this type theory for correct-by-construction parsers and
  parser combinators.
\end{abstract}

\maketitle

\section{A Syntax-Independent Notion of Syntax}
\todoin{Rework intro from LICS draft with a focus on implementation}
Formal language theory is among one of the oldest and most studied areas in
theoretical computer science.

Informally, a grammar $G$ is often described generatively as a set of production rules for
generating strings. Often this is presented as a finite set of nonterminal
symbols $N$, a finite set of terminal symbols $\Sigma$, and a finite set of rewriting
rules for substitution of nonterminals. In this setting, we continually apply
rewrite rules until we are left only with a string of terminals
$s \in \Sigma^{*}$. \todoin{cite chomsky}

One of the primary objects of study is that of a \emph{formal language} over
a fixed alphabet $\Sigma$. A language $L$ is a \emph{subset} of strings
$L \subseteq \Sigma^{*}$. This notion of formal language gives an intuitive
set-based semantics for grammars. That is, we may interpret a grammar $G$ as the
language $L(G)$ that is generated by it.


\section{Non-commutative Linear-non-linear Type Theory as a Syntax for Formal Grammars}
\missingfigure{Inference Rules}
\missingfigure{Axioms}

\section{Type Theoretic Formal Grammar Theory}

\section{Automata as Grammars}

\subsection{Finite Automata}

\subsection{Equivalence Between Regular Grammars and Finite Automata}

\subsection{Brzozowski Derivatives and Deterministic Finite Automata}
\todoin{You should know complexity statements about all this classic stuff like
  Brzozowski's alg}

\subsection{Pushdown Automata}

\subsection{Turing Machines}

\section{Future Work}
\subsection{Formalization}
\todoin{proofs in agda}

\subsection{Implementation of a Verfied Parser}
\todoin{sell how this should be used for building verified code}
\todoin{talk about the need for a verified parser because compcert yadda yadda}

\subsection{Beyond Strings}


\end{document}
